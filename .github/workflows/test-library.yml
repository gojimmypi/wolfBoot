name: wolfBoot as Library test

on:
  push:
    # TODO: branches: [ 'master', 'main', 'release/**' ]
    branches: [ '*' ]
  pull_request:
    branches: [ '*' ]

jobs:
  test-lib:
    # If jobs cancel, consider pinning to ubuntu-24.04
    # The ubuntu-latest alias can point to different images during migrations (and sometimes be extra busy),
    # while ubuntu-24.04 always targets the 24.04 pool
    runs-on: ubuntu-latest

    # The timeout is run time after a runner starts, not time in queue
    timeout-minutes: 15

    strategy:
      fail-fast: false

      # Limit concurrent jobs for scheduling problem on GitHub's hosted runner pool.
      max-parallel: 12

      matrix:
        math:
          - "SPMATH=1 WOLFBOOT_SMALL_STACK=0"
          - "SPMATH=1 WOLFBOOT_SMALL_STACK=1"
          - "SPMATHALL=1 WOLFBOOT_SMALL_STACK=0"
          - "SPMATHALL=1 WOLFBOOT_SMALL_STACK=1"
          - "SPMATH=0 SPMATHALL=0 WOLFBOOT_SMALL_STACK=0"
          - "SPMATH=0 SPMATHALL=0 WOLFBOOT_SMALL_STACK=1"
        asym: [ed25519, ecc256, ecc384, ecc521, rsa2048, rsa3072, rsa4096, ed448]
        hash: [sha256, sha384, sha3]

        # See https://github.com/wolfSSL/wolfBoot/issues/614 regarding exclusions:
        # TODO disabled, expect failure until resolved:
        # exclude:
        #  - math: "SPMATH=1 WOLFBOOT_SMALL_STACK=1"
        #  - math: "SPMATHALL=1 WOLFBOOT_SMALL_STACK=1"

    steps:
      - uses: actions/checkout@v4
        with:
          clean: true
          submodules: true

      - name: hard clean
        run: |
          # Ensure parallel build did not leave behind any debris
          make clean || true
          make keysclean || true
          make -C tools/keytools clean || true

          # The brute-force clean:
          rm -rf build build-*     \
                 test-app          \
                 build/vis_hal     \
                 build/vis_cmsis   \
                 **/*.o            \
                 **/*.d            \
                 **/*.a            \
                 include/target.h  \
                 src/keystore.c

      - name: Build test-lib
        env:
          shell: bash
          ASYM: ${{ matrix.asym }}
          HASH: ${{ matrix.hash }}
          MATH: ${{ matrix.math }}
        run: |
          # Test various library parameters

          export SIGN="${ASYM^^}"
          export HASH="${HASH^^}"
          export MATH='${{ matrix.math }}' # e.g., "SPMATH=1 WOLFBOOT_SMALL_STACK=1"
          export PRIVATE_KEY="wolfboot_signing_private_key.der"

          echo "This SIGN=$SIGN"
          echo "This HASH=$HASH"
          echo "This MATH=$MATH"

          # Sample build
          build_once() {
              # Convert asym and hash to upper case, optionally add additional param
              echo "Build..."
              echo "make -j test-lib SIGN=${ASYM^^} HASH=${HASH^^} ${MATH} \"$@\""
              make -j test-lib SIGN=${ASYM^^} HASH=${HASH^^} ${MATH} "$@"
          }

          set -euo pipefail

          # Get the reference config
          cp config/examples/library.config .config

          # peek
          echo "Existing files?"
          if [ -f "src/keystore.c" ]; then
            echo "WARNING: Found unexpected src/keystore.c"
          fi
          if [ -f "include/target.h" ]; then
            echo "WARNING: Found unexpected include/target.h"
          fi
          if [ -f "keystore.der" ]; then
            echo "WARNING: Found unexpected keystore.der"
          fi
          if [ -f "wolfboot_signing_private_key.der" ]; then
            echo "WARNING: Found unexpected wolfboot_signing_private_key.der"
          fi

          # Keytools
          echo ""
          echo "make keytools SIGN=\"${ASYM}\" HASH=\"${HASH}\" $MATH"
          make keytools SIGN="${ASYM}" HASH="${HASH}" $MATH
          ./tools/keytools/keygen --${ASYM} -g wolfboot_signing_private_key.der

          # Sign
          echo ""
          echo "Sign test.bin"
          echo "./tools/keytools/sign --${SIGN} --${HASH} test.bin wolfboot_signing_private_key.der 1"
          echo "Test" > test.bin
          ./tools/keytools/sign --${SIGN} --${HASH} test.bin wolfboot_signing_private_key.der 1

          # First attempt
          if build_once >build.out 2>build.err; then
            echo "Success on first attempt, WOLFBOOT_HUGE_STACK not applied."
            cat build.out
            cat build.err
            exit 0
          fi

          # If it failed due to the TFM huge stack guard, retry with the flag
          if grep -Fq 'If this is OK, please compile with WOLFBOOT_HUGE_STACK=1' build.err; then
            echo "Retrying with WOLFBOOT_HUGE_STACK=1 due to stack requirement error."

            # Always print the entire message
            grep -Fn 'If this is OK, please compile with WOLFBOOT_HUGE_STACK=1' build.err || true

            # Try again with huge stack allowed
            build_once WOLFBOOT_HUGE_STACK=1
          else
            echo "Build failed for another reason:"
            cat build.out
            cat build.err
            exit 1
          fi

      - name: Run test-lib
        run: |
          # Check test_v1_signed.bin

          echo "./test-lib test_v1_signed.bin"
          ./test-lib test_v1_signed.bin
          ./test-lib test_v1_signed.bin 2>&1 | grep "Firmware Valid"

      - name: Run test-lib (expect failure)
        run: |
          # Corrupt signed binary
          truncate -s -1 test_v1_signed.bin
          echo "A" >> test_v1_signed.bin
          ./test-lib test_v1_signed.bin
          ./test-lib test_v1_signed.bin 2>&1 | grep "Failure"
